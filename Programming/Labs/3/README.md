# Лабораторная работа № 3
## Алгоритмы внутренней сортировки
### Теоретическая часть
#### Постановка задачи сортировки
Задача сортировки формулируется так. Дана последовательность из n однотипных
записей, одно из полей которых выбрано в качестве ключевого (такое поле принято
называть ключом сортировки). Ключи сортировки выбираются из множества, на
котором задан линейный порядок (обычно его обозначают символом "<="). На
практике в качестве ключа часто выступает число, а в остальных полях
хранятся какие-либо данные, никак не влияющие на работу алгоритма. Требуется
найти перестановку  этих n записей, которая отобразит исходную
последовательность в неубывающую результирующую последовательность. Как
правило, алгоритм сортировки вырабатывает саму упорядоченную
последовательность, а не упорядочивающую перестановку . 

#### Оценка алгоритмов сортировки 
Двумя важными мерами сложности любого алгоритма являются временная и емкостная
сложности, рассматриваемые как функции размера входа.  
Временная сложность - математическое время выполнения алгоритма сортировки,
измеряемое в условных единицах времени. Обычно временную сложность
рассматривают как функцию длины входной последовательности. Рассмотрение
входных данных большого размера и оценка порядка роста времени работы
алгоритма приводят к понятию асимптотической сложности алгоритма. Для
упорядочения важны худшее, среднее и лучшее поведение алгоритма в терминах
длины входной последовательности. Для типичного алгоритма хорошее
поведение — это O(n log n) и плохое поведение — O(n2). Идеальное поведение для
упорядочения — O(n). Алгоритмы сортировки, использующие операцию сравнения
ключей, всегда нуждаются, по меньшей мере, в O(n log n) сравнениях.  
Емкостная (пространственная) сложность —  число условных единиц памяти (объём
используемой памяти), необходимых для выполнения алгоритма. При оценке
емкостной сложности не учитывается место, которое занимает исходная 
последовательность. Алгоритмы сортировки, использующие дополнительную память,
как правило, требуют O(log n) памяти.

##### Классификация алгоритмов сортировки
По сфере применения различают:
* внутренние сортировки, которые оперирует с последовательностями, целиком
помещающимися в оперативной памяти, и
* внешние сортировки, которые упорядочивают информацию, расположенную на
внешних носителях.

##### По типу последовательности различают: 
* сортировки массивов — упорядоченных наборов данных одного типа,
идентифицируемых с помощью индекса, и 
* сортировки cвязных списков — структур данных, состоящих из узлов, каждый
из которых содержит как собственные данные, так и одну или две ссылки
(«связки») на следующий и/или предыдущий узел.

В работе рассматриваются наиболее известные методы внутренней сортировки,
начиная с самых простых и понятных, но не слишком быстрых, и заканчивая
более сложными, но и более быстрыми. 
Поскольку, как было замечено ранее, сортировка основана только на
значениях ключа и никак не зависит от оставшихся полей записи, то далее
в примерах будет рассматриваться сортировка массивов ключей.

##### Усовершенствованные алгоритмы внутренней сортировки
Усовершенствованные алгоритмы внутренней сортировки зачастую разрабатываются с
помощью метода декомпозиции: сложная задача разбивается на несколько более
простых, которые подобны исходной задаче, но имеют меньший объем; далее эти
вспомогательные задачи решаются рекурсивным методом, после чего полученные
решения комбинируются с целью получить решение исходной задачи. Каждый
уровень рекурсии включает в себя три этапа.

1. Разделение задачи на несколько подзадач. 
2. Покорение - рекурсивное решение этих подзадач. Когда объем подзадачи
достаточно мал, выделенные подзадачи решаются непосредственно.
3. Комбинирование решения исходной задачи из решений вспомогательных задач.
Далее в работе рассматриваются три усовершенствованных алгоритма внутренней
сортировки:
1. Алгоритм сортировки слиянием (фон Нейман).
2. Алгоритм пирамидальной сортировки (Вильямс и Флойд).
3. Алгоритм быстрой сортировки (Хоар).

### Задание
1. Ознакомиться с элементарными алгоритмами внутренней сортировки.
2. Изучить и реализовать один усовершенствованный алгоритм внутренней
сортировки в соответствии с предложенным вариантом. Сортировка должна
проводиться по любым трем ключам записи.
3. Осуществить быстрый поиск заданной записи с помощью стандартной функции
`bsearch`. Пример применения функции bsearch к отсортированному массиву с
помощью стандартной функции qsort приведен в Приложении 1.
4. Экспериментально оценить временную сложность разработанной программы
сортировки.
5. Для проведения экспериментов массив записей заполнить данными из
XML-файла, указанного в варианте.

**Замечание**. Может быть вам в первый и в последний раз в жизни придется
«вручную» обрабатывать XML-файл. Современная технология программирования давно
автоматизировала эти процессы. Так, например, в библиотеке классов платформы
.NET Framework имеется пространство имен System.Xml, содержащее дочерние
пространства имен, такие, как `System.Xml.Linq`, `System.Xml.Resolvers`,
`System.Xml.Schema`, `System.Xml.Serialization`,
`System.Xml.Serialization.Advanced`, `System.Xml.Serialization.Configuration`,
`System.Xml.XPath`, `System.Xml.Xsl`, `System.Xml.Xsl.Runtime`. Эти
пространства имен содержат сотни типов (читай классов) для обработки XML-файлов
и языков XML. Эти классы поддерживают сериализацию XML-документов или потоков,
схемы XSD, язык XQuery 1.0, язык XPath 2.0, а также интерфейс LINQ to XML,
который является хранимым в памяти интерфейсом программирования XML,
позволяющим удобным образом изменять XML-документы. 

Взять, к примеру, класс XPathNodeIterator из пространства имен
`System.Xml.XPath`, который обеспечивает итератор над выбранным набором узлов.
Чтобы распечатать содержимое всех узлов документа, ассоциированного с файлом
`books.xml`:
```
<?xml version="1.0" encoding="utf-8" ?> 
<bookstore>
    <book genre="autobiography" publicationdate="1981-03-22" ISBN="1-861003-11-0">
        <title>The Autobiography of Benjamin Franklin</title>
        <author>
            <first-name>Benjamin</first-name>
            <last-name>Franklin</last-name>
        </author>
        <price>8.99</price>
    </book>
    <book genre="novel" publicationdate="1967-11-17" ISBN="0-201-63361-2">
        <title>The Confidence Man</title>
        <author>
            <first-name>Herman</first-name>
            <last-name>Melville</last-name>
        </author>
        <price>11.99</price>
    </book>
    <book genre="philosophy" publicationdate="1991-02-15" ISBN="1-861001-57-6">
        <title>The Gorgias</title>
        <author>
            <name>Plato</name>
        </author>
        <price>9.99</price>
    </book>
</bookstore>
```
надо выполнить следующую программу на языке C#:
```
using System;
using System.Xml;
using System.Xml.XPath;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            XPathDocument document = new XPathDocument("books.xml");
            XPathNavigator navigator = document.CreateNavigator();

            XPathNodeIterator nodes = navigator.Select("/bookstore");
            nodes.MoveNext();
            XPathNavigator nodesNavigator = nodes.Current;

            XPathNodeIterator nodesText = nodesNavigator.SelectDescendants(XPathNodeType.Text, false);

            while (nodesText.MoveNext())
                Console.WriteLine(nodesText.Current.Value);
            Console.ReadLine();
        }
    }
}
```
Результат выполнения программы будет таким:
```
The Autobiography of Benjamin Franklin
Benjamin
Franklin
8.99
The Confidence Man
Herman
Melville
11.99
The Gorgias
Plato
9.99
```
Программа на языке C++/CLI, решающая аналогичную задачу, будет иметь вид:
```
#include "stdafx.h"

using namespace System;
using namespace System::Xml;
using namespace System::Xml::XPath;

int main(array<System::String ^> ^args)
{
	XPathDocument^ document = gcnew XPathDocument("books.xml");
	XPathNavigator^ navigator = document->CreateNavigator();

	XPathNodeIterator^ nodes = navigator->Select("/bookstore");
	nodes->MoveNext();
	XPathNavigator^ nodesNavigator = nodes->Current;

	XPathNodeIterator^ nodesText = nodesNavigator->SelectDescendants(XPathNodeType::Text, false);

	while (nodesText->MoveNext())
		Console::WriteLine(nodesText->Current->Value);

	Console::ReadLine();
    return 0;
}
```
А  пока все придется делать «вручную»!!!

**Вариант 1.**

Метод сортировки: сортировка слиянием.
Тип записи:
```
struct Customer {
	int CustomerID;
	char Title[8];
	char FirstName[50];
	char LastName[50];
	char CompanyName[128];
	char EmailAddress[50];
	char Phone[25];
};
```
Файл данных: `Customers.xml`