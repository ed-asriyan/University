# Лабораторная работа 2
**Цель работы:** реализовать операции со стеком, представленным в виде массива
(1 случай) и в виде линейного списка (2 случай), оценить преимущества и
недостатки каждой реализации.

**Общее задание:** создать программу работы со стеком, выполняющую операции
добавление, удаления элементов и вывод текущего состояния стека. Реализовать
стек:
1. массивом;
2. списком.

Все стандартные операции со стеком должны быть оформлены подпрограммами.
При реализации стека списком в вывод текущего состояния стека добавить
просмотр адресов элементов стека и создать свой список или массив свободных
областей (адресов освобождаемых элементов) с выводом его на экран.

**Задание к варианту:** Используя стек, определить, является ли строка
палиндромом.

## Техническое задание
* Программа имеет приглашение на английском языке для пользователя для ввода
необходимых данных;
* Входные данные:
  * Строка неограниченной длины;
  * Тип, которые будет использоваться программой:
    * динамически зацикленный буфер;
    * список;
* Выходные данные: сообщение о том, является ли введённая строка палиндромом:
  * Является;
  * Не является;
* Возможное ошибки: нет;

## Алгоритм проверки на палиндром
1. Создаётся пустой стек;
2. Все элементы строки, находящиеся в первой её половине, по порядку, один
за другим, считываются и добавляются в стек (`Push`). Пусть длина строки равна
`N`. Первая половина это
   * если `N` — чётное, `0 — N/2` (включительно) элементы строки;
   * если `N` — нечётное, `0 — (N-1)/2` (включительно) элементы строки;
3. По порядку для каждго элемента строки, находящегося во второй половине
строки, выполняются следующие действия:
   1. Считывается текущий элемент;
   2. Считывается и удаляется последний элемент из стека (`Pop`);
   3. Если если оба этих значения не идентичны, алгоритм прерывается,
   выводится сообщение о том, что строка не является палиндромом;
   
   Пусть длина строки равна N. Первая половина это
   * если `N` — чётное, `(N/2)+1` — `(N-1)` (включительно) элементы строки;
   * если `N` — нечётное, `(N+1)/2` — `(N-1)` (включительно) элементы строки;
4. Печатается сообщение о том, что строка является палиндромом.

## Реализация стека с помощью динамически зацикленного буфера
### Внутри стека хранятся следующие данные:
* `data` — массив (его так же называют буфер), хранящий содержимое стека,
размер которого может быть больше или равен количеству элементов,
содержащихся в контейнере;
* `data_size` — размер буфера;
* `size` — количество элементов в стеке;

### Метод `Pop`:
1. Если размер стека равен нулю (`size == 0`), выкидывается исключение;
2. Возвращается `data[size — 1]`, size уменьшается на `1`;

### Метод `Push`:
1. Если `data_size == size + 1`, размер массива `data` увеличивается в 3 раза,
`data_size` увеличивается в то же количество раз;
2. Новый элемент записывается в `data[size]`;
3. size увеличивается на `1`.

**Аварийные случаи:** вызов `Pop` для пустого стека.

## Реализация стека с помощью списка (нод)
Для данного способа создан вспомогательный класс, который выполняет роль
ноды. Он хранит следующие данные:
* значение;
* указатель на предыдущий элемент.
### В стеке элементами являются ноды, он хранит
* указатель на последний элемент (`back`), изначально равен `NULL`;
* размер стека.
### Метод `Pop`:
* если размер стека равен нулю, выкидывается исключение;
* возвращается значение последней ноды и происходит её удаление.
### Метод `Push`:
* создаётся новая нода, ей присваивается значение. Её указатель на предыдущий
элемент равен указателю на последний элемент в стеке;
* последний элемент в стеке = новой ноде;

**Аварийные случаи:** вызов Pop для пустого стека.

## Тесты
Для обоих типов стеков результаты тестов должны совпадать.

| Входная строка | Результат |
|----------------|-----------|
| qwerty | No |
| qwedsaasdewq | Yes |
| qwq | Yes |
| P | Yes |
| | Yes |
| qw | No |

## Сложность алгоритмов
* Способ с динамически зацикленным буфером
  * Сложность медода `Pop`
    * Средняя: O(1)
    * Худшая: O(1)
  * Сложность метода `Push`
    * Средняя: O(1)
    * Худшая: O(n)
* Способ с нодами
  * Сложность медода `Pop`
    * Средняя: O(1)
    * Худшая: O(1)
  * Сложность метода `Push`
    * Средняя: O(1)
    * Худшая: O(1)
    
Для двух способов сложности совпадают везде, кроме худшего случая метода
`Push`: зацикленный буфер выдаёт линейный результат, в то время как
списковый подход даёт константу. Это происходит из-за того, что в тот
момент, когда буфер заполняется до конца, происходит перераспределение
памяти: выделяется новый участок памяти нового размера, копируются элементы
из буферы в него, старый буфер удаляется, новый участок памяти заменяет его.

Таким образом, способ создания списка нодами является более эффективным при
малых размерах контейнера. При больших – скорости при большинстве случаев
будут одинаковы.

Теперь рассмотрим эффективность по памяти. Первый способ выделяет память
только под данные, которые добавляет пользователь, второй — на данные и для
каждого элемента стека указатель на предыдущий элемент. Несмотря на то, что
в обоих случаях потребляемость памяти растёт линейно, второй способ
потребляет больше памяти.

## Результаты тестов
Тесты проводились для стека, реализованном на списке и динамически
зацикленном буфере для методов `Push` и `Pop` на следующий тапах данных: `int`,
`double`, `char`, `std::string`. Так как время выполнения данных функций
очень мало, было принято решение замерять несколько их вызовов.
Итак, результаты:

### Списковый подход

| Кол-во вызовов | Метод | `int` | `double` | `char` | `std::string` |
|----------------|-------|-------|----------|--------|---------------|
| 10 | `Push` | 3e-06 | 4e-06 | 4e-06 | 2.1e-05 |
| 10 | `Pop` | 0 | 1e-06 | 0 | 3e-06 |
| 100 | `Push` | 6e-06 | 9e-06 | 6e-06 | 3.1e-05 |
| 100 | `Pop` | 2e-06 | 1e-06 | 1e-06 | 3e-06 |
| 1000 | `Push` | 3e-05 | 5.9e-05 | 2.8e-05 | 0.000203 |
| 1000 | `Pop` | 1.4e-05 | 1.4e-05 | 1.4e-05 | 3e-05|
| 10000 | `Push` | 0.000283 | 0.000583 | 0.000268 | 0.002195 |
| 10000 | `Pop` | 0.000135 | 0.000137 | 0.000134 | 0.000297 |
| 100000 | `Push` | 0.002927 | 0.006137 | 0.002671 | 0.03497 |
| 100000 | `Pop` | 0.001362 | 0.001386 | 0.001361 | 0.00302 |
| 1000000 | `Push` | 0.027782 | 0.056471 | 0.026088 | 0.273524 |
| 1000000 | `Pop` | 0.013748 | 0.013964 | 0.013652 | 0.030466 |


### Подход с буфером

| Кол-во вызовов | Метод | `int` | `double` | `char` | `std::string` |
|----------------|-------|-------|----------|--------|---------------|
| 10 | `Push` | 3e-06 | 4e-06 | 3e-06 | 2.7e-05 |
| 10 | `Pop` | 1e-06 | 1e-06 | 1e-06 | 3e-06 |
| 100 | `Push` | 1.1e-05 | 1.4e-05 | 1.3e-05 | 3.1e-05 |
| 100 | `Pop` | 3e-06 | 3e-06 | 3e-06 | 4e-06 |
| 1000 | `Push` | 0.000101 | 0.000132 | 0.000106 | 0.00025 |
| 1000 | `Pop` | 2.7e-05 | 2.8e-05 | 2.7e-05 | 4.7e-05 |
| 10000 | `Push` | 0.000992 | 0.001228 | 0.001141 | 0.002493 |
| 10000 | `Pop` | 0.000278 | 0.000295 | 0.000271 | 0.000478 |
| 100000 | `Push` | 0.01028 | 0.012905 | 0.011149 | 0.025952 |
| 100000 | `Pop` | 0.002807 | 0.002822 | 0.002879 | 0.004881 |
| 1000000 | `Push` | 0.102444 | 0.128173 | 0.109935 | 0.257301 |
| 1000000 | `Pop` | 0.028235 | 0.028618 | 0.027898 | 0.049472 |

Как видно из тестов, стек, реализованный на нодах, работает быстрее, но,
чем больше количество операций (т. е. при больших размерах стека), тем
меньше различие времени выполнения (в разах). Это не удивительно, ведь
средние сложности у двух подходах равны.

**Вывод:** для хранения данных небольшого количества лучше использовать подход
с нодами, так как не будет происходить лишнего копирования при
перераспределении памяти; для большого количества данных лучше выбрать
способ динамически зацикленного буфера, так как перераспределение памяти
будет происходить редко и не будет храниться вспомогательная информация в
каждой ноде.