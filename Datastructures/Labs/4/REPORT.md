# Лабораторная работа 4
## Условия задачи
Система массового обслуживания состоит из двух обслуживающих аппаратов (ОА1 и ОА2) и двух очередей заявок. Всего в 
системе обращается 100 заявок. Заявки поступают в "хвост" каждой очереди; в ОА они поступают из "головы" очереди по 
одной и обслуживаются по случайному закону за интервалы времени `Т1` и `Т2`, равномерно распределенные от 0 до 6 и от 1 
до 8 единиц времени соответственно. (Все времена – вещественного типа).  Каждая заявка после ОА1 c вероятностью Р=0.7
вновь поступает в "хвост" первой очереди, совершая новый цикл обслуживания, а с вероятностью 1-Р входит во вторую
очередь. В начале процесса все заявки находятся в первой очереди. Смоделировать процесс обслуживания до выхода из 
ОА2 первых 1000 заявок. Выдавать на экран после обслуживания  в ОА2 каждых 100 заявок информацию о текущей и 
средней длине каждой очереди, а в конце процесса - общее время моделирования, время простоя ОА2, количество 
срабатываний ОА1, среднее времени пребывания заявок в очереди.

## ТЗ
### Исходные данные и результаты
**Входные данные:** выбор (да/нет): выводить или нет адреса элементов для очереди, построенной на списке. 

**Результат работы:**  
Для каждого типа ОА:
* количество обработанных заявок;
* время простоя;
* время работы
* средняя длина очереди;
* среднее время обслуживания;

### Описание реализации ОА
Существует два ОА: один основан на очереди на списке, второй - на очереди на массиве. На каждом шаге ОА случайным
образом вычисляет время обработки заявки в указанном диапазоне и обрабатывает одну заявку (переводит ее из входной
очереди в выходную). При добавлении, если очередь пустая, увеличивается время простоя на разность между текущим временем
и временем последней обаботки.

## Описание внутренних структур данных
### RequestUnit

| Тип | Имя | Описание |
|-----|-----|----------|
| int | proc_count | кол-во прохождений через ОА |
| double | queuing_time | время в очереди |
| double | service_time | время обслуживания |

### QueueListNode

| Тип | Имя | Описание |
|-----|-----|----------|
| RequestUnit | value | значение |
| QueueListNode* | prev | предыдущий узел |


### QueueList

| Тип | Имя | Описание |
|-----|-----|----------|
| QueueLisеNode* | head | голова очереди |
| QueueLisеNode* | tail | конец очереди |
| int | size | длина очереди |

### QueueArray

| Тип | Имя | Описание |
|-----|-----|----------|
| RequestUnit* | head | голова очереди |
| RequestUnit* | tail | конец очереди |
| int | size | длина очереди |


### ServiceUnit

| Тип | Имя | Описание |
|-----|-----|----------|
| Queue | requests | очередь заявок |
| double | curr_time | текщее время моделирования |
| double | min_proc_time | минимальное время обработки |
| double | max_proc_time | максимальное время обработки |
| double | sum_proc_time | суммарное время обработки заявок |
| double | sum_queuing_time | суммарное время очереди |
| int | sum_size | сумма длин очереди |
| int | proc_count | количество обработанных заявок |

## Сравнение реализаций

| Реализация | Кол-во тиков |
|------------|--------------|
| Массив | 207668 |
| Список | 26615 |

## Вывод
Очередь, основання на списке, работает намного быстрее (в ~8 раз), чем та, что основана на массиве. Это и следовало
ожидать, так как во в первом случае добавление и удаление работает всегда за `O(1)`, а во втором за `O(1)` в лучшем и за
`O(n)` в худшем случае (хотя амортизированное время - `O(1)`).