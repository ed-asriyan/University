# Лабораторная работа 3
## Условия задачи
Система массового обслуживания состоит из двух обслуживающих аппаратов (ОА1 и ОА2) и двух очередей заявок. Всего в 
системе обращается 100 заявок. Заявки поступают в "хвост" каждой очереди; в ОА они поступают из "головы" очереди по 
одной и обслуживаются по случайному закону за интервалы времени `Т1` и `Т2`, равномерно распределенные от 0 до 6 и от 1 
до 8 единиц времени соответственно. (Все времена – вещественного типа).  Каждая заявка после ОА1 c вероятностью Р=0.7
вновь поступает в "хвост" первой очереди, совершая новый цикл обслуживания, а с вероятностью 1-Р входит во вторую
очередь. В начале процесса все заявки находятся в первой очереди. Смоделировать процесс обслуживания до выхода из 
ОА2 первых 1000 заявок. Выдавать на экран после обслуживания  в ОА2 каждых 100 заявок информацию о текущей и 
средней длине каждой очереди, а в конце процесса - общее время моделирования, время простоя ОА2, количество 
срабатываний ОА1, среднее времени пребывания заявок в очереди.

## ТЗ
### Исходные данные и результаты
**Входные данные:** очередь к ОА1, содержащая 100 заявок.
**Результат работы:** время моделирования, время простоя ОА2, количество срабатываний ОА1, среднее времени пребывания 
заявок в очереди.

### Описание задачи, реализуемой программой
Для каждого ОА существуют две очереди (входная и выходная), реализованные в виде массива или списка. На каждом шаге 
ОА случайным образом вычисляет время обработки заявки в указанном диапазоне и обрабатывает одну заявку (переводит ее 
из входной очереди в выходную). Основная программа с заданной вероятностью переводит заявки из выходной очереди ОА1 
во входную очередь ОА2 или обратно во входную очередь ОА1.

## Описание внутренних структур данных
### RequestUnit

| Тип | Имя | Описание |
|-----|-----|----------|
| int | proc_count | кол-во прохождений через ОА |
| double | queuing_time | время в очереди |
| double | service_time | время обслуживания |

### QueueListNode

| Тип | Имя | Описание |
|-----|-----|----------|
| RequestUnit | value | значение |
| QueueListNode* | prev | предыдущий узел |


### QueueList

| Тип | Имя | Описание |
|-----|-----|----------|
| QueueLisNode* | head | голова очереди |
| QueueLisNode* | tail | конец очереди |
| int | count | длина очереди |

### QueueArray

| Тип | Имя | Описание |
|-----|-----|----------|
| RequestUnit* | data | данные |
| int | size | размер |


### ServiceUnit

| Тип | Имя | Описание |
|-----|-----|----------|
| Queue | requests | очередь заявок |
| double | curr_time | текщее время моделирования |
| double | min_proc_time | минимальное время обработки |
| double | max_proc_time | максимальное время обработки |
| double | sum_proc_time | суммарное время обработки заявок |
| double | sum_queuing_time | суммарное время очереди |
| int | sum_size | сумма длин очереди |
| int | proc_count | количество обработанных заявок |

## Сравнение реализаций

| Реализация | Кол-во тиков |
|------------|--------------|
| Массив | 202153136 |
| Список | 286775063 |

При реализации очереди в виде массива все операции выполняются в среднем в 1,5 раза быстрее. Каждый элемент 
очереди-списка занимает в памяти 40 байт. Буфер под 150 элементов очереди-массива занимает в памяти 4848 байт (~ 32 
байта на элемент). Очередь-массив в 1,25 раза эффективнее по памяти (не считая необходимости заранее выделять 
ограниченный буфер).