# Лабораторная работа №5
## Условия задачи
Разреженная (содержащая много нулей) матрица хранится в форме 3-х объектов:
* вектор `A` содержит значения ненулевых элементов;
* вектор `IA` содержит номера строк для элементов вектора `A`;
* связный список `JA`, в элементе `Nk` которого находится номер компонент в `A` и `IA`, с которых начинается описание
столбца `Nk` матрицы `A`.

1. Смоделировать операцию сложения двух матриц, хранящихся в этой форме, с получением результата в той же форме.
2. Произвести операцию сложения, применяя стандартный алгоритм работы с матрицами.
3. Сравнить время выполнения операций и объем памяти при использовании этих 2-х алгоритмов при различном проценте
заполнения матриц.

## ТЗ
### Исходные данные и результаты
**Входные данные:** две разреженные матрицы или информация для генерации случайных матриц (размер и/или `g`). Если `g` 
задаётся, матрицы генерируются программой, в ином случае матрица считывается с стандартного потока ввода. Если размеры
матрицы не задаются, она по умолчанию равны 1000x1000.

Все данные должны приходить из аргументов, передаваемых программе. Синтаксис:
```bash
./Matrix [ui] [g] [высота [ширина]]
```

Парамет `ui` включает диалог с пользователем для ввода матрицы с клавиатуры.

**Результат работы:**
* если её размер не превышает размера 20x20
  * первая исхождная матрица;
  * вторая исходная матрица;
  * матрица, равная сумме двух исходных матриц
* для каждого из алгоритмов (классический, разряжённый)
  * время сложения матриц в тиках;
  * объем памяти, занимаемый каждой матрицей, в байтах.

### Описание задачи, реализуемой программой
Две разреженные матрицы вводятся со стандартного потока или заполняются случайным образом. Дополнительно обе матрицы
переводятся в обычный вид (если размер матриц меньше 20). Производится сложение матриц в разреженном и в обычном виде,
замеряется время работы алгоритмов.

### Возможные аварийные ситуации и ошибки пользователя
* Некорректный ввод с клавиатуры;
* Ошибки выделения памяти.

## Описание внутренних структур данных
### ClassicMatrix
```objectivec
struct ClassicMatrix {  // классическая матрица
	int data;           // значение матрицы
	int height;         // высота
	int width;          // ширина
};
```

### SparseMatrix
```objectivec
struct SparseMatrix {   // разряженная матрица
	Vector aj;          // указатели на первую ноду в списке с соответствующей строкой
	List ia;            // список значений
	int height;         // высота
	int width;	        // ширина
};
```

## Производительность
Результаты для полученой матрицы (равной сумме двух исходных). Размер 1000x1000.

### Время работы
|  Процент заполненности  | ClassicMatrix | SparseMatrix | Отношение |
|-----|---------------|--------------|-----------|
| 0   | 23351 | 78 | 0.003 |
| 2 | 23552 | 24139 | 1.02 |
| 4 | 22679 | 69262 | 3.05 |
| 6 | 22934 | 127878 | 5.57 |
| 8 | 22835 | 203683 | 8.919 |
| 10 | 22698 | 293023 | 12.909 |
| 15 | 22843 | 574953 | 25.169 |
| 20 | 22908 | 930008 | 40.597 |
| 25 | 22644 | 1346533 | 59.465 |
| 30 | 22865 | 1811395 | 79.228 |
| 35 | 22944 | 2316974 | 100.984 |

## Объем занимаемой памяти
|  Процент заполненности  | ClassicMatrix | SparseMatrix | Отношение |
|-----|---------------|--------------|-----------|
| 0   | 4008032 | 8104 | 0.002 |
| 2 | 4008032 | 404444 | 0.100 |
| 4 | 4008032 | 166984 | 0.197 |
| 6 | 4008032 | 1172964 | 0.292 |
| 8 | 4008032 | 1548284 | 0.386 |
| 10 | 4008032 | 1914784 | 0.477 |
| 15 | 4008032 | 2793844 | 0.697 |
| 20 | 4008032 | 3634064 | 0.906 |
| 25 | 4008032 | 4429024 | 1.105 |
| 30 | 4008032 | 5193144 | 1.295 |
| 35 | 4008032 | 5914324 | 1.475 |

## Выводы
* Использование разряженных матриц даёт выигрыш по времени, если заполнение меньше 4% от количества элементов в
матрице.
* По памяти они дают выигрыш, если заполнение менее 25%.

Из таблицы видно, что с увеличением процента заполнения алгоритм потребляет больше памяти, причём чем выше процент, тем
быстрее падает производительность (как по времени, так и по памяти).

## Контрольные вопросы
1. **Что такое разреженная матрица, какие схемы хранения таких матриц Вы знаете?** В виде матриц достаточно широко
представляется информация во многих областях человеческой жизнедеятельности. Матричные задачи часто используются при
решении разреженных линейных алгебраических уравнений; разреженных обычных и обобщенных спектральных задач, при этом
матрицы могут быть достаточно большие (больше 10^(10~20) элементов), а число ненулевых элементов при матрице порядка `n`
может выражаться как `n`, где `g < 1`.
2. **Каким образом и сколько памяти выделяется под хранение разреженной и обычной матрицы?** Существуют различные методы
хранения элементов матрицы в памяти. Например, линейный связный список, т.е. последовательность ячеек, связанных в
определенном порядке. Каждая ячейка списка содержит элемент списка и указатель на положение следующей ячейки. Можно
хранить матрицу, используя кольцевой связный список, двунаправленные стеки и очереди. Существует диагональная схема
хранения симметричных матриц, а также связные схемы разреженного хранения.
3. **Каков принцип обработки разреженной матрицы?** *Разреженный вектор* - это разреженная матрица-строка или
матрица-столбец, поэтому рассмотрим скалярное умножение разреженных векторов (как частный случай работы с матрицей) с
использованием так называемого расширенного массива указателей IP. При вычислении стандартным способом нужно `N^2`
просмотров массива. Для сокращения алгебраических операций удобно во время работы хранить расширенный (по размерности
массивов `a` и `b`) массив указателей `IP` (его начальное состояние - нулевое). Этот массив заполняется путем одного
просмотра массива `JA`.
4. **В каком случае для матриц эффективнее применять стандартные алгоритмы обработки матриц? От чего это зависит?** В
случае, если матрица содержит большое количество ненулевых элементов. При этом не должно стоять значительных ограничений
по памяти, так как стандартные матрицы при больших размерностях занимают достаточно много памяти.
