# Лабораторная работа №5
## Условия задачи
Разреженная (содержащая много нулей) матрица хранится в форме 3-х объектов:
* вектор `A` содержит значения ненулевых элементов;
* вектор `IA` содержит номера строк для элементов вектора `A`;
* связный список `JA`, в элементе `Nk` которого находится номер компонент в `A` и `IA`, с которых начинается описание
столбца `Nk` матрицы `A`.

1. Смоделировать операцию сложения двух матриц, хранящихся в этой форме, с получением результата в той же форме.
2. Произвести операцию сложения, применяя стандартный алгоритм работы с матрицами.
3. Сравнить время выполнения операций и объем памяти при использовании этих 2-х алгоритмов при различном проценте
заполнения матриц.

## ТЗ
### Исходные данные и результаты
**Входные данные:** две разреженные матрицы или информация для генерации случайных матриц (размер и/или `g`). Если `g` 
задаётся, матрицы генерируются программой, в ином случае матрица считывается с стандартного потока ввода. Если размеры
матрицы не задаются, она по умолчанию равны 1000x1000.

Все данные должны приходить из аргументов, передаваемых программе. Синтаксис:
```bash
./Matrix [g] [высота [ширина]]
```

**Результат работы:**
* если её размер не превышает размера 20x20
  * первая исхождная матрица;
  * вторая исходная матрица;
  * матрица, равная сумме двух исходных матриц
* для каждого из алгоритмов (классический, разряжённый)
  * время сложения матриц в тиках;
  * объем памяти, занимаемый каждой матрицей, в байтах.

### Описание задачи, реализуемой программой
Две разреженные матрицы вводятся со стандартного потока или заполняются случайным образом. Дополнительно обе матрицы
переводятся в обычный вид (если размер матриц меньше 20). Производится сложение матриц в разреженном и в обычном виде,
замеряется время работы алгоритмов.

### Возможные аварийные ситуации и ошибки пользователя
* Некорректный ввод с клавиатуры;
* Ошибки выделения памяти.

## Описание внутренних структур данных
### ClassicMatrix
```objectivec
struct ClassicMatrix {  // классическая матрица
	int data;           // значение матрицы
	int height;         // высота
	int width;          // ширина
};
```

### SparseMatrix
```objectivec
struct SparseMatrix {   // разряженная матрица
	Vector aj;          // указатели на первую ноду в списке с соответствующей строкой
	List ia;            // список значений
	int height;         // высота
	int width;	        // ширина
};
```

## Производительность
Результаты для полученой матрицы (равной сумме двух исходных). Размер 1000x1000.

### Время работы
|  g  | ClassicMatrix | SparseMatrix | Отношение |
|-----|---------------|--------------|-----------|
| 0   | 238737 | 22011 | 0.092 |
| 0.1 | 21896 | 297631 | 13.592 |
| 0.2 | 22096 | 406270 | 18.386 |
| 0.3 | 21689 | 656092 | 30.249 |
| 0.4 | 22188 | 1908622 | 86.020 |
| 0.5 | 21952 | 4987856 | 227.216 |
| 0.6 | 21247 | 9868727 | 464.476 |
| 0.7 | 21341 | 19433501 | 910.618 |
| 0.8 | 21165 | 36543450 | 1726.598 |
| 0.9 | 21447 | 64927629 | 3027.352 |
| 1   | 21166 | 79607259 | 3761.091 |

## Объем занимаемой памяти
|  g  | ClassicMatrix | SparseMatrix | Отношение |
|-----|---------------|--------------|-----------|
| 0   | 4008032 | 28104 | 0.007 |
| 0.1 | 4008032 | 87864 | 0.021 |
| 0.2 | 4008032 | 166984 | 0.041 |
| 0.3 | 4008032 | 324444 | 0.080 |
| 0.4 | 4008032 | 637104 | 0.158 |
| 0.5 | 4008032 | 1252984 | 0.312 |
| 0.6 | 4008032 | 2451884 | 0.611 |
| 0.7 | 4008032 | 4725284 | 1.178 |
| 0.8 | 4008032 | 8792364 | 2.193 |
| 0.9 | 4008032 | 15030964 | 3.750 |
| 1   | 4008032 | 20008104 | 4.992 |

## Выводы
* Использование разряженных матриц даёт выигрыш по времени, если заполнение меньше 10% от количества элементов в
матрице.
* По памяти они дают выигрыш, если заполнение менее 60%.

Из таблицы видно, что с увеличением процента заполнения алгоритм потребляет больше памяти, причём чем выше процент, тем
быстрее падает производительность (как по времени, так и по памяти).

## Контрольные вопросы
1. **Что такое разреженная матрица, какие схемы хранения таких матриц Вы знаете?** В виде матриц достаточно широко
представляется информация во многих областях человеческой жизнедеятельности. Матричные задачи часто используются при
решении разреженных линейных алгебраических уравнений; разреженных обычных и обобщенных спектральных задач, при этом
матрицы могут быть достаточно большие (больше 10^(10~20) элементов), а число ненулевых элементов при матрице порядка `n`
может выражаться как `n`, где `g < 1`.
2. **Каким образом и сколько памяти выделяется под хранение разреженной и обычной матрицы?** Существуют различные методы
хранения элементов матрицы в памяти. Например, линейный связный список, т.е. последовательность ячеек, связанных в
определенном порядке. Каждая ячейка списка содержит элемент списка и указатель на положение следующей ячейки. Можно
хранить матрицу, используя кольцевой связный список, двунаправленные стеки и очереди. Существует диагональная схема
хранения симметричных матриц, а также связные схемы разреженного хранения.
3. **Каков принцип обработки разреженной матрицы?** *Разреженный вектор* - это разреженная матрица-строка или
матрица-столбец, поэтому рассмотрим скалярное умножение разреженных векторов (как частный случай работы с матрицей) с
использованием так называемого расширенного массива указателей IP. При вычислении стандартным способом нужно `N^2`
просмотров массива. Для сокращения алгебраических операций удобно во время работы хранить расширенный (по размерности
массивов `a` и `b`) массив указателей `IP` (его начальное состояние - нулевое). Этот массив заполняется путем одного
просмотра массива `JA`.
4. **В каком случае для матриц эффективнее применять стандартные алгоритмы обработки матриц? От чего это зависит?** В
случае, если матрица содержит большое количество ненулевых элементов. При этом не должно стоять значительных ограничений
по памяти, так как стандартные матрицы при больших размерностях занимают достаточно много памяти.
