# Лабораторная работа №5
## Условия задачи
Разреженная (содержащая много нулей) матрица хранится в форме 3-х объектов:
* вектор `A` содержит значения ненулевых элементов;
* вектор `IA` содержит номера строк для элементов вектора `A`;
* связный список `JA`, в элементе `Nk` которого находится номер компонент в `A` и `IA`, с которых начинается описание
столбца `Nk` матрицы `A`.

1. Смоделировать операцию сложения двух матриц, хранящихся в этой форме, с получением результата в той же форме.
2. Произвести операцию сложения, применяя стандартный алгоритм работы с матрицами.
3. Сравнить время выполнения операций и объем памяти при использовании этих 2-х алгоритмов при различном проценте
заполнения матриц.

## ТЗ
### Исходные данные и результаты
**Входные данные:** две разреженные матрицы или информация для генерации случайных матриц (размер и/или `g`). Если `g` 
задаётся, матрицы генерируются программой, в ином случае матрица считывается с стандартного потока ввода. Если размеры
матрицы не задаются, она по умолчанию равны 1000x1000.

Все данные должны приходить из аргументов, передаваемых программе. Синтаксис:
```bash
./Matrix [ui] [g] [высота [ширина]]
```

Парамет `ui` включает диалог с пользователем для ввода матрицы с клавиатуры.

**Результат работы:**
* если её размер не превышает размера 20x20
  * первая исхождная матрица;
  * вторая исходная матрица;
  * матрица, равная сумме двух исходных матриц
* для каждого из алгоритмов (классический, разряжённый)
  * время сложения матриц в тиках;
  * объем памяти, занимаемый каждой матрицей, в байтах.

### Описание задачи, реализуемой программой
Две разреженные матрицы вводятся со стандартного потока или заполняются случайным образом. Дополнительно обе матрицы
переводятся в обычный вид (если размер матриц меньше 20). Производится сложение матриц в разреженном и в обычном виде,
замеряется время работы алгоритмов.

### Возможные аварийные ситуации и ошибки пользователя
* Некорректный ввод с клавиатуры;
* Ошибки выделения памяти.

## Описание внутренних структур данных
### ClassicMatrix
```objectivec
struct ClassicMatrix {  // классическая матрица
	int data;           // значение матрицы
	int height;         // высота
	int width;          // ширина
};
```

### SparseMatrix
```objectivec
struct SparseMatrix {   // разряженная матрица
	Vector aj;          // указатели на первую ноду в списке с соответствующей строкой
	List ia;            // список значений
	int height;         // высота
	int width;	        // ширина
};
```

## Тесты
```
Generating matrix (fill factor is 0.02)...
Adding matrix...
Done!

Equality check:
 Classic A == sparse A
 Classic B == sparse B
 Classic C == sparse C

Classic matrix (1000x1000):
 Addition time: 24119
 Size of A: 4008032
 Size of B: 4008032
 Size of C: 4008032

Sparse matrix (1000x1000):
 Addition time: 21273  (ratio: 0.882002)
 Size of A: 166640  (ratio: 0.0415765)
 Size of B: 166456  (ratio: 0.0415306)
 Size of C: 166456  (ratio: 0.0415306)
```

## Сравнение реализаций
Результаты для полученой матрицы (равной сумме двух исходных). Размер 1000x1000.

### Время работы
|  Процент заполненности  | ClassicMatrix | SparseMatrix | Отношение |
|-------------------------|---------------|--------------|-----------|
| 0 | 23496 | 66 | 0.002 |
| 2 | 23423 | 20708 | 0.884 |
| 4 | 23692 | 59232 | 2.500 |
| 6 | 23604 | 114614 | 4.855 |
| 8 | 23663 | 184109 | 7.780 |
| 10 | 23599 | 268598 | 11.381 |
| 15 | 23515 | 534384 | 22.725 |
| 20 | 23697 | 870329 | 36.727 |
| 25 | 23736 | 1269497 | 53.484 |
| 30 | 23654 | 1706851 | 72.159 |
| 35 | 23625 | 2186772 | 92.561 |


### Объем занимаемой памяти
|  Процент заполненности  | ClassicMatrix | SparseMatrix | Отношение |
|-----|-------------------|--------------|-----------|
| 0   | 4008032 | 8080 | 0.002 |
| 2 | 4008032 | 166568 | 0.041 |
| 4 | 4008032 | 321896 | 0.080 |
| 6 | 4008032 | 473952 | 0.118 |
| 8 | 4008032 | 623856 | 0.155 |
| 10 | 4008032 | 769336 | 0.191 |
| 15 | 4008032 | 1121344 | 0.279 |
| 20 | 4008032 | 1458688 | 0.363 |
| 25 | 4008032 | 1779400 | 0.443 |
| 30 | 4008032 | 2082184 | 0.519 |
| 35 | 4008032 | 2370744 | 0.591 |
| 40 | 4008032 | 2646496 | 0.660 |
| 45 | 4008032 | 2908064 | 0.725 |
| 50 | 4008032 | 3155216 | 0.787 |
| 55 | 4008032 | 3396320 | 0.847 |
| 60 | 4008032 | 3619536 | 0.903 |
| 65 | 4008032 | 3831944 | 0.956 |
| 70 | 4008032 | 4038312 | 1.007 |
| 75 | 4008032 | 4233928 | 1.056 |

## Выводы
* Использование разряженных матриц даёт выигрыш по времени, если заполнение меньше 4% от количества элементов в
матрице.
* По памяти они дают выигрыш, если заполнение менее 25%.

Из таблицы видно, что с увеличением процента заполнения алгоритм потребляет больше памяти, причём чем выше процент, тем
быстрее падает производительность (как по времени, так и по памяти).

## Контрольные вопросы
1. **Что такое разреженная матрица, какие схемы хранения таких матриц Вы знаете?** В виде матриц достаточно широко
представляется информация во многих областях человеческой жизнедеятельности. Матричные задачи часто используются при
решении разреженных линейных алгебраических уравнений; разреженных обычных и обобщенных спектральных задач, при этом
матрицы могут быть достаточно большие (больше 10^(10~20) элементов), а число ненулевых элементов при матрице порядка `n`
может выражаться как `n`, где `g < 1`.
2. **Каким образом и сколько памяти выделяется под хранение разреженной и обычной матрицы?** Существуют различные методы
хранения элементов матрицы в памяти. Например, линейный связный список, т.е. последовательность ячеек, связанных в
определенном порядке. Каждая ячейка списка содержит элемент списка и указатель на положение следующей ячейки. Можно
хранить матрицу, используя кольцевой связный список, двунаправленные стеки и очереди. Существует диагональная схема
хранения симметричных матриц, а также связные схемы разреженного хранения.
3. **Каков принцип обработки разреженной матрицы?** *Разреженный вектор* - это разреженная матрица-строка или
матрица-столбец, поэтому рассмотрим скалярное умножение разреженных векторов (как частный случай работы с матрицей) с
использованием так называемого расширенного массива указателей IP. При вычислении стандартным способом нужно `N^2`
просмотров массива. Для сокращения алгебраических операций удобно во время работы хранить расширенный (по размерности
массивов `a` и `b`) массив указателей `IP` (его начальное состояние - нулевое). Этот массив заполняется путем одного
просмотра массива `JA`.
4. **В каком случае для матриц эффективнее применять стандартные алгоритмы обработки матриц? От чего это зависит?** В
случае, если матрица содержит большое количество ненулевых элементов. При этом не должно стоять значительных ограничений
по памяти, так как стандартные матрицы при больших размерностях занимают достаточно много памяти.
