# Лабораторная работа 3
**Общее задание:** создать таблицу, содержащую не менее 40 записей с вариантной
частью. Упорядочить таблицу по возрастанию ключей (где ключ – любое
невариантное поле по выбору программиста), используя:
1. исходную таблицу;
2. массив ключей.

Сравнить различные алгоритмы сортировки массива при использовании таблиц
записей с большим числом полей и таблиц ключей. Оценить эффективность (по
времени и по используемому объему памяти) при различной реализации программы,
то есть в случаях (1) и (2).

**Таблица:** список машин, содержащий марку автомобиля, страну-производитель,
цену, цвет и состояние: новый – гарантия (в годах); нет - год выпуска, пробег,
количество ремонтов.

## Техническое задание
Осуществляются операции (добавление записи, удаление записи и т.д.) с таблицей
записей и таблицей ключей, представленными в памяти в виде массива записей.

**Входные данные:** бинарный файл, представляющий таблицу записей с вариантной
частью.

**Выходные данные:** список записей, удовлетворяющих условиям (все марки не
новых машин указанного цвета с пробегом меньше 10 тыс. км и отсутствием
ремонта). Таблица записей, отсортированная по невариантному полю.
Отсортированная таблица ключей. Время работы для различных сортировок.

**Возможные ошибки:**
* Открытие несуществующего файла
  * Сообщение:
    ```
    { Unable to load! }
    ```
* Открытие файла с некорректным форматом данных

| Содержимое файла   | Результат  | Пояснение |
|--------------------|------------|-----------|
|      | `{ Unable to load! }`  | Пустой файл |
| 2<br>Suzuki SX4<br>Black<br>Japan<br>1304000<br>0<br>4 | `{ Unable to load! }`  | Ожидается 2 элемента, а записан 1 |
| `qaaq` | `{ Unable to load! }`  | Ожидается целое, подана строка |
    
## Описание структур данных
### Автомобиль
```
struct Car {
	char model[STR_LEN];                  // марка машины
	char country[STR_LEN];                // страна-производитель
	int price;                            // цена
	char color[STR_LEN];                  // цвет
	int used;                             // подержанная/новая

	union {
		// если подержанная
		struct {
			int warranty;          // гарантия   
		} new_car;

		// если новая
		struct {
			int year;              // год
			int mileage;           // пробег
			int repairs_count;     // количество ремонтов
		} used_car;
	} united;
};
```

### Таблица автомобилей
```
struct CarTable {
	struct Car* ptr_first;                 // первый элемент таблицы
	int n;                                 // размер таблицы
	int n_max;                             // максимальный размер таблицы
};
```

### Ключ
```
struct Key {
	int key;                               // значение
	int id;                                // номер в таблице
};
```

### Таблица ключей
```
struct KeyTable {
	struct Key* ptr_first;                 // первый элемент таблицы
	int n;                                 // размер таблицы
};
```

## Время выполнения

| Метод сортировки | Сортируемая таблица | Количество тиков |
|------------------|---------------------|------------------|
| Быстрая | Автомобилей | 37738495 |
| Быстрая | Ключей | 6703275 |
| Пузырёк | Автомобилей | 119089667 |
| Пузырёк | Ключей | 47050226 |

## Количество потребляемой памяти

| Таблица автомобилей (42 записи) | Таблица ключей (42 записи) |
|---------------------------------|----------------------------|
| 7392 B | 336 B |

## Вывод
* Таблица ключей сортируется примерно в 5 раз быстрее, чем исходная таблица;
* Быстрая сортировка примерно в 3 раза быстрее, чем сортировка пузырьком.

## Ответы на вопросы
1. **Как выделяется память под вариантную часть записи?** – Выделяется область
памяти, равная размеру максимального по длине поля вариантной части.
2. **Что будет, если в вариантную часть ввести данные, несоответствующие
описанным?** – Тип данных в вариантной части при компиляции не проверяется, все
проверки необходимо осуществлять самостоятельно.
3. **Кто должен следить за правильностью выполнения операций с вариантной частью
записи?** – Разработчик.
4. **Что представляет собой таблица ключей, зачем она нужна?** – Таблица ключей
содержит индекс элемента в исходной таблице и выбранный ключ. За счет небольших
дополнительных затрат памяти позволяет ускорить процесс поиска и сортировки
элементов исходной таблицы.
5. **В каких случаях эффективнее обрабатывать данные в самой таблице, а когда
– использовать таблицу ключей?** – Использовать таблицу ключей эффективнее в
случае большого количества записей или большого размера памяти, необходимой
для хранения каждой записи.
6. **Какие способы сортировки предпочтительнее для обработки таблиц и почему?**
– При сортировке таблиц эффективнее использовать таблицу ключей. При этом
быстрая сортировка работает быстрее, чем сортировка пузырьком.
