# Отчет по лабораторной работе №1

## Условия задачи
Составить программу деления двух чисел, где порядок имеет до 5 знаков: от
–99999 до +99999, а мантисса – до 30 знаков. Программа должна осуществлять ввод
чисел и выдавать либо верный результат в указанном формате (при корректных
данных), либо сообщение о невозможности произвести счет.

## ТЗ
### Исходные данные и результаты
Смоделировать операцию деления действительного числа на действительное число в
форме +-m.nE+-K, где суммарная длина  мантиссы (m+n) – до 30 значащих цифр, а
величина порядка K – до 5 цифр. Результат выдать в форме +-0.m1, где m1 – до
30 значащих цифр, а K1 – до  5 цифр.

#### Входные данные
Делимое и делитель – действительные числа. Возможны следующие варианты и
представления:
* „Е“ и „е“ - допустимые равнозначные.
* +-m.n
* +-m.n
* +-0.m;
* +-0.m e+-K
* +-.m eE+-K;
* +-m.n E-+K;
* -+me+-K;
* +-m e; // степень = 0;

Результат работы: на экран выводится вещественное число, являющееся
результатом деления двух введенных, в экспоненциальной форме +-0.m1 Е +-K1,
где число m1 определено до 30 значащих цифр, число K1 – до 5 цифр. При
невозможности произвести вычисления или неправильном формате входных данных
выдается сообщение об ошибке и работа программы прекращается.

### Описание задачи, реализуемой программой
Осуществляется деление двух вещественных десятичных чисел по аналогии с
помощью последовательных операций вычитания.

### Способ обращения к программе
Запуск исполняемого файла, ввод исходных данных с клавиатуры в окно консоли.

#### Аварийные ситуации
* Неверный ввод числа – сообщение об ошибке ввода;
* Пустое поле ввода – ничего не произойдет, программа будет ждать ввода пользователя;
* Переполнение порядка – сообщение о переполнении;
* Деление на ноль – сообщение о запрещение деления на ноль.

#### Описание использованных структур данных
Для представления чисел используется тип данных массив.
```
char num1[50];        // число 1 в виде строке
char num2[50];        // число 2 в виде строки
int num_power1 = 0;   // степень числа 1
int num_power2 = 0;   // степень числа 2
int znak_number1 = 1; // знак числа 1 (1 - "+" 0 - '-')
int znak_number2 = 1; // знак числа 2 (1 - "+" 0 - '-')
int lenarr1 = 0;      // длина массива 1
int lenarr2 = 0;      // длина массива 2
```

## Описание алгоритма
Два вещественных десятичных числа (числитель и знаменатель) считываются со
стандартного потока ввода (с клавиатуры). Производятся проверки на
правильность формата ввода. Производится проверка на равенство нулю
знаменателя. Если какая-либо проверка не проходит, выводится соответствующее
сообщение об ошибке и программа завершает свою работу.

По алгоритму деления в столбик последовательно вычисляются цифры и порядок
результирующего числа. Шаг деления происходит следующим образом: оба числа
нормализуются, запоминается разность иx  порядков, порядки отбрасываются.
Если Знаменатель оказывается больше числителя, он смещается вправо на один
разряд. Пока числитель больше знаменателя, производится вычитание знаменателя
из числителя с инкрементом значения счетчика. Значение счетчика после
выполнения цикла – очередная десятичная цифра результирующего числа.
Сохраненная разность порядков – смещение относительно предыдущих цифр.

После вычисления необходимого количества разрядов результирующего числа оно
округляется, производится проверка на переполнение экспоненты. В случае
переполнения выводится сообщение об ошибке. Иначе выводится результирующее
число в нормализованной экспоненциальной форме.

### Тесты
| Делимое | Делитель | Результат |
|---------|----------|-----------|
| -123e5 | 1 | -0123e+8 |
| 34.234e+5 | 0 | ERROR |
| 0 | 0 | ERROR |
| 2 | 3 | 0.666666666666666666667e0 |
| 12334567890123456789012345678901e+124 | 456456 | ERROR |
| 3457.345e+23487487 | 456 | ERROR |
| 1233456.7890123456789012345678901e+124 | 56 | ERROR |
| 999999999999999999999999999999 | 999999999999999999999999999999 | 0.1e1 |
| -999999999999999999999999999999 | -999999999999999999999999999999 | 0.1e1 |
| -999999999999999999999999999999 | 999999999999999999999999999999 | -0.1e1 |
| 999999999999999999999999999999 | -999999999999999999999999999999 | -0.1e1 |
| 345e+99999 | 345e+99999 | 0.1e1 |
| 345e+99999 | -345e+99999 | -0.1e1 |
| 123.4e+99999 | 1234 | 0.1e99999 |
| 123sdf | ---- | ERROR |
| 456 | 123sfg | ERROR |
| 123.4 | 1234e-99999 | 0.1e99999 |

## Контрольные вопросы
1. **Каков возможный диапазон чисел, представляемых в ПК?**
Диапазон чисел напрямую зависит от области памяти, выделяемый под хранение
переменной, наличия знака, а также типа представления числа (вещественное
или целое). К примеру, если целая беззнаковая переменная типа integer
занимает 4 байта (16 бит), то диапазон её значений: 0..2^16-1 - 0..65535.
Если же она может принимать также и положительные значения, то диапазон:
-2^15..2^15-1

2. **Какова возможная точность представления чисел?**
Вещественные числа хранятся в представлении с плавающей точкой в виде
`X = M * E^p`, где М – мантисса, представленная правильной дробью (в
интервале [0.1..1) ). Точность представленяи вещественного числа зависит от
максимально возможной длины мантиссы, которая, опять-таки, зависит от
области выделяемой памяти и наличия знака. Если длина мантиссы выходит за
границы разрядной сетки, то происходит округление.

3. **Какие стандартные операции возможны над числами?**
Стандартные операции над числами – сложение, вычитание, умножение, деление.

4. **Какой тип данных может выбрать программист, если обрабатываемые числа
превышают возможный диапазон представления чисел в ПК?**
Для представления чисел, превышающих возможный диапазон, может быть
использован массив из цифр (например, переменных занимающих 1 байт) –
простейший случай представления целого беззнакового числа. В общем случае
можно использовать, например, структуру, содержащую массив цифр мантиссы,
массив цифр порядка, и два Boolean флага для хранения знаков мантиссы и
порядка.

5. **Как можно осуществить операции над числами, выходящими за рамки
машинного представления?**
Операции над большими числами можно выполнять путём последователного
выполнения операций над всеми цифрами, составляющими число, начиная с
«хвоста» массива цифр.