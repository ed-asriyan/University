# Лабораторная работа №5
## Условия задачи
Разреженная (содержащая много нулей) матрица хранится в форме 3-х объектов:
* вектор `A` содержит значения ненулевых элементов;
* вектор `IA` содержит номера строк для элементов вектора `A`;
* связный список `JA`, в элементе `Nk` которого находится номер компонент в `A` и `IA`, с которых начинается описание
столбца `Nk` матрицы `A`.

1. Смоделировать операцию сложения двух матриц, хранящихся в этой форме, с получением результата в той же форме.
2. Произвести операцию сложения, применяя стандартный алгоритм работы с матрицами.
3. Сравнить время выполнения операций и объем памяти при использовании этих 2-х алгоритмов при различном проценте
заполнения матриц.

## ТЗ
### Исходные данные и результаты
**Входные данные:** две разреженные матрицы или информация для генерации случайных матриц (размер и/или `g`). Если `g` 
задаётся, матрицы генерируются программой, в ином случае матрица считывается с стандартного потока ввода. Если размеры
матрицы не задаются, она по умолчанию равны 1000x1000.

Все данные должны приходить из аргументов, передаваемых программе. Синтаксис:
```bash
./Matrix [ui] [g] [высота [ширина]]
```

Парамет `ui` включает диалог с пользователем для ввода матрицы с клавиатуры.

**Результат работы:**
* если её размер не превышает размера 20x20
  * первая исхождная матрица;
  * вторая исходная матрица;
  * матрица, равная сумме двух исходных матриц
* для каждого из алгоритмов (классический, разрежённый)
  * время сложения матриц в тиках;
  * объем памяти, занимаемый каждой матрицей, в байтах.

### Описание задачи, реализуемой программой
Две разреженные матрицы вводятся со стандартного потока или заполняются случайным образом. Дополнительно обе матрицы
переводятся в обычный вид (если размер матриц меньше 20). Производится сложение матриц в разреженном и в обычном виде,
замеряется время работы алгоритмов.

### Возможные аварийные ситуации и ошибки пользователя
* Некорректный ввод с клавиатуры;
* Ошибки выделения памяти.

## Описание внутренних структур данных
### ClassicMatrix
```objectivec
struct ClassicMatrix {  // классическая матрица
	int data;           // значение матрицы
	int height;         // высота
	int width;          // ширина
};
```

### SparseMatrix
```objectivec
struct SparseMatrix {   // разреженная матрица
	Vector aj;          // указатели на первую ноду в списке с соответствующей строкой
	List ia;            // список значений
	int height;         // высота
	int width;	        // ширина
};
```

## Тесты
### Вывод в обычном виде
```
Generating matrix (fill factor is 0.5)...
Adding matrix...
Done!

Matrix A: 
  4  2  0  0  0  0  0  0  0  0   |   4  2  0  0  0  0  0  0  0  0
  0  0  9  4  0  0  0  0  8  2   |   0  0  9  4  0  0  0  0  8  2
  4  0  0  0  8  0  4  6  0  5   |   4  0  0  0  8  0  4  6  0  5
  0  5  0  2  8  0  0  0  0  2   |   0  5  0  2  8  0  0  0  0  2
  1  4  5  0  0  7  0  0  0  4   |   1  4  5  0  0  7  0  0  0  4
  0  0  7  0  0  0  6  5  3  0   |   0  0  7  0  0  0  6  5  3  0
  6  0  0 10  5  5  0  0  0  0   |   6  0  0 10  5  5  0  0  0  0
  0  0  0  0  0  9  5  0  1  0   |   0  0  0  0  0  9  5  0  1  0
  0  0  0  0  6  0  6  2  0  0   |   0  0  0  0  6  0  6  2  0  0
  0  0  0  0  0  8  6  1  5  7   |   0  0  0  0  0  8  6  1  5  7

Matrix B: 
  0  2  0  5  0  8  0  0  1  0   |   0  2  0  5  0  8  0  0  1  0
  0  0  0  4  8  0  9  0  0  0   |   0  0  0  4  8  0  9  0  0  0
  0  1  9  0  4  2  0  0 10  0   |   0  1  9  0  4  2  0  0 10  0
  6  0  0  2  0  0  4  2  0 10   |   6  0  0  2  0  0  4  2  0 10
  0  7  0  0  0  6  5  0 10  5   |   0  7  0  0  0  6  5  0 10  5
  2  1  0  0  0  1  0  5  0 10   |   2  1  0  0  0  1  0  5  0 10
  0  4  5  1  0  0  0  0  8  0   |   0  4  5  1  0  0  0  0  8  0
  0  0 10  0  0 10  2  9  2  0   |   0  0 10  0  0 10  2  9  2  0
  0  0  3  0  9  0  0  5  0 10   |   0  0  3  0  9  0  0  5  0 10
 10  0  0  0  0  0  6  5  0  0   |  10  0  0  0  0  0  6  5  0  0

Matrix C = A + B: 
  4  4  0  5  0  8  0  0  1  0   |   4  4  0  5  0  8  0  0  1  0
  0  0  9  8  8  0  9  0  8  2   |   0  0  9  8  8  0  9  0  8  2
  4  1  9  0 12  2  4  6 10  5   |   4  1  9  0 12  2  4  6 10  5
  6  5  0  4  8  0  4  2  0 12   |   6  5  0  4  8  0  4  2  0 12
  1 11  5  0  0 13  5  0 10  9   |   1 11  5  0  0 13  5  0 10  9
  2  1  7  0  0  1  6 10  3 10   |   2  1  7  0  0  1  6 10  3 10
  6  4  5 11  5  5  0  0  8  0   |   6  4  5 11  5  5  0  0  8  0
  0  0 10  0  0 19  7  9  3  0   |   0  0 10  0  0 19  7  9  3  0
  0  0  3  0 15  0  6  7  0 10   |   0  0  3  0 15  0  6  7  0 10
 10  0  0  0  0  8 12  6  5  7   |  10  0  0  0  0  8 12  6  5  7

Equality check:
 Classic A == sparse A
 Classic B == sparse B
 Classic C == sparse C

Classic matrix (10x10):
 Addition time: 17
 Size of A: 512
 Size of B: 512
 Size of C: 512

Sparse matrix (10x10):
 Addition time: 171  (ratio: 10.0588)
 Size of A: 464  (ratio: 0.90625)
 Size of B: 496  (ratio: 0.96875)
 Size of C: 672  (ratio: 1.3125)
```

### Вывод только ненулевых элементов
```
Generating matrix (fill factor is 0.5)...
Adding matrix...
Done!

Matrix A: 
  4  2  0  0  0  0  0  0  0  0   |   4  2  0  0  0  0  0  0  0  0
  0  0  9  4  0  0  0  0  8  2   |   0  0  9  4  0  0  0  0  8  2
  4  0  0  0  8  0  4  6  0  5   |   4  0  0  0  8  0  4  6  0  5
  0  5  0  2  8  0  0  0  0  2   |   0  5  0  2  8  0  0  0  0  2
  1  4  5  0  0  7  0  0  0  4   |   1  4  5  0  0  7  0  0  0  4
  0  0  7  0  0  0  6  5  3  0   |   0  0  7  0  0  0  6  5  3  0
  6  0  0 10  5  5  0  0  0  0   |   6  0  0 10  5  5  0  0  0  0
  0  0  0  0  0  9  5  0  1  0   |   0  0  0  0  0  9  5  0  1  0
  0  0  0  0  6  0  6  2  0  0   |   0  0  0  0  6  0  6  2  0  0
  0  0  0  0  0  8  6  1  5  7   |   0  0  0  0  0  8  6  1  5  7

Matrix B: 
  0  2  0  5  0  8  0  0  1  0   |   0  2  0  5  0  8  0  0  1  0
  0  0  0  4  8  0  9  0  0  0   |   0  0  0  4  8  0  9  0  0  0
  0  1  9  0  4  2  0  0 10  0   |   0  1  9  0  4  2  0  0 10  0
  6  0  0  2  0  0  4  2  0 10   |   6  0  0  2  0  0  4  2  0 10
  0  7  0  0  0  6  5  0 10  5   |   0  7  0  0  0  6  5  0 10  5
  2  1  0  0  0  1  0  5  0 10   |   2  1  0  0  0  1  0  5  0 10
  0  4  5  1  0  0  0  0  8  0   |   0  4  5  1  0  0  0  0  8  0
  0  0 10  0  0 10  2  9  2  0   |   0  0 10  0  0 10  2  9  2  0
  0  0  3  0  9  0  0  5  0 10   |   0  0  3  0  9  0  0  5  0 10
 10  0  0  0  0  0  6  5  0  0   |  10  0  0  0  0  0  6  5  0  0

Matrix C = A + B: 
  4  4  0  5  0  8  0  0  1  0   |   4  4  0  5  0  8  0  0  1  0
  0  0  9  8  8  0  9  0  8  2   |   0  0  9  8  8  0  9  0  8  2
  4  1  9  0 12  2  4  6 10  5   |   4  1  9  0 12  2  4  6 10  5
  6  5  0  4  8  0  4  2  0 12   |   6  5  0  4  8  0  4  2  0 12
  1 11  5  0  0 13  5  0 10  9   |   1 11  5  0  0 13  5  0 10  9
  2  1  7  0  0  1  6 10  3 10   |   2  1  7  0  0  1  6 10  3 10
  6  4  5 11  5  5  0  0  8  0   |   6  4  5 11  5  5  0  0  8  0
  0  0 10  0  0 19  7  9  3  0   |   0  0 10  0  0 19  7  9  3  0
  0  0  3  0 15  0  6  7  0 10   |   0  0  3  0 15  0  6  7  0 10
 10  0  0  0  0  8 12  6  5  7   |  10  0  0  0  0  8 12  6  5  7

Equality check:
 Classic A == sparse A
 Classic B == sparse B
 Classic C == sparse C

Classic matrix (10x10):
 Addition time: 17
 Size of A: 512
 Size of B: 512
 Size of C: 512

Sparse matrix (10x10):
 Addition time: 171  (ratio: 10.0588)
 Size of A: 464  (ratio: 0.90625)
 Size of B: 496  (ratio: 0.96875)
 Size of C: 672  (ratio: 1.3125)
```

### Матрицы маленькой размерности
```
Generating matrix (fill factor is 0.5)...
Adding matrix...
Done!

Matrix A: 
  4  2  0  0  0  0  0  0  0  0   |   4  2  0  0  0  0  0  0  0  0
  0  0  9  4  0  0  0  0  8  2   |   0  0  9  4  0  0  0  0  8  2
  4  0  0  0  8  0  4  6  0  5   |   4  0  0  0  8  0  4  6  0  5
  0  5  0  2  8  0  0  0  0  2   |   0  5  0  2  8  0  0  0  0  2
  1  4  5  0  0  7  0  0  0  4   |   1  4  5  0  0  7  0  0  0  4
  0  0  7  0  0  0  6  5  3  0   |   0  0  7  0  0  0  6  5  3  0
  6  0  0 10  5  5  0  0  0  0   |   6  0  0 10  5  5  0  0  0  0
  0  0  0  0  0  9  5  0  1  0   |   0  0  0  0  0  9  5  0  1  0
  0  0  0  0  6  0  6  2  0  0   |   0  0  0  0  6  0  6  2  0  0
  0  0  0  0  0  8  6  1  5  7   |   0  0  0  0  0  8  6  1  5  7

Matrix B: 
  0  2  0  5  0  8  0  0  1  0   |   0  2  0  5  0  8  0  0  1  0
  0  0  0  4  8  0  9  0  0  0   |   0  0  0  4  8  0  9  0  0  0
  0  1  9  0  4  2  0  0 10  0   |   0  1  9  0  4  2  0  0 10  0
  6  0  0  2  0  0  4  2  0 10   |   6  0  0  2  0  0  4  2  0 10
  0  7  0  0  0  6  5  0 10  5   |   0  7  0  0  0  6  5  0 10  5
  2  1  0  0  0  1  0  5  0 10   |   2  1  0  0  0  1  0  5  0 10
  0  4  5  1  0  0  0  0  8  0   |   0  4  5  1  0  0  0  0  8  0
  0  0 10  0  0 10  2  9  2  0   |   0  0 10  0  0 10  2  9  2  0
  0  0  3  0  9  0  0  5  0 10   |   0  0  3  0  9  0  0  5  0 10
 10  0  0  0  0  0  6  5  0  0   |  10  0  0  0  0  0  6  5  0  0

Matrix C = A + B: 
  4  4  0  5  0  8  0  0  1  0   |   4  4  0  5  0  8  0  0  1  0
  0  0  9  8  8  0  9  0  8  2   |   0  0  9  8  8  0  9  0  8  2
  4  1  9  0 12  2  4  6 10  5   |   4  1  9  0 12  2  4  6 10  5
  6  5  0  4  8  0  4  2  0 12   |   6  5  0  4  8  0  4  2  0 12
  1 11  5  0  0 13  5  0 10  9   |   1 11  5  0  0 13  5  0 10  9
  2  1  7  0  0  1  6 10  3 10   |   2  1  7  0  0  1  6 10  3 10
  6  4  5 11  5  5  0  0  8  0   |   6  4  5 11  5  5  0  0  8  0
  0  0 10  0  0 19  7  9  3  0   |   0  0 10  0  0 19  7  9  3  0
  0  0  3  0 15  0  6  7  0 10   |   0  0  3  0 15  0  6  7  0 10
 10  0  0  0  0  8 12  6  5  7   |  10  0  0  0  0  8 12  6  5  7

Equality check:
 Classic A == sparse A
 Classic B == sparse B
 Classic C == sparse C

Classic matrix (10x10):
 Addition time: 17
 Size of A: 512
 Size of B: 512
 Size of C: 512

Sparse matrix (10x10):
 Addition time: 171  (ratio: 10.0588)
 Size of A: 464  (ratio: 0.90625)
 Size of B: 496  (ratio: 0.96875)
 Size of C: 672  (ratio: 1.3125)
```

## Сравнение реализаций
Результаты для полученой матрицы (равной сумме двух исходных). Размер 1000x1000.

### Время работы
|  Процент заполненности  | ClassicMatrix | SparseMatrix | Отношение |
|-------------------------|---------------|--------------|-----------|
| 0 | 23496 | 66 | 0.002 |
| 2 | 23423 | 20708 | 0.884 |
| 4 | 23692 | 59232 | 2.500 |
| 6 | 23604 | 114614 | 4.855 |
| 8 | 23663 | 184109 | 7.780 |
| 10 | 23599 | 268598 | 11.381 |
| 15 | 23515 | 534384 | 22.725 |
| 20 | 23697 | 870329 | 36.727 |
| 25 | 23736 | 1269497 | 53.484 |
| 30 | 23654 | 1706851 | 72.159 |
| 35 | 23625 | 2186772 | 92.561 |


### Объем занимаемой памяти
|  Процент заполненности  | ClassicMatrix | SparseMatrix | Отношение |
|-----|-------------------|--------------|-----------|
| 0   | 4008032 | 8080 | 0.002 |
| 2 | 4008032 | 166568 | 0.041 |
| 4 | 4008032 | 321896 | 0.080 |
| 6 | 4008032 | 473952 | 0.118 |
| 8 | 4008032 | 623856 | 0.155 |
| 10 | 4008032 | 769336 | 0.191 |
| 15 | 4008032 | 1121344 | 0.279 |
| 20 | 4008032 | 1458688 | 0.363 |
| 25 | 4008032 | 1779400 | 0.443 |
| 30 | 4008032 | 2082184 | 0.519 |
| 35 | 4008032 | 2370744 | 0.591 |
| 40 | 4008032 | 2646496 | 0.660 |
| 45 | 4008032 | 2908064 | 0.725 |
| 50 | 4008032 | 3155216 | 0.787 |
| 55 | 4008032 | 3396320 | 0.847 |
| 60 | 4008032 | 3619536 | 0.903 |
| 65 | 4008032 | 3831944 | 0.956 |
| 70 | 4008032 | 4038312 | 1.007 |
| 75 | 4008032 | 4233928 | 1.056 |

## Выводы
* Использование разреженных матриц даёт выигрыш по времени, если заполнение меньше 4% от количества элементов в
матрице.
* По памяти они дают выигрыш, если заполнение менее 25%.
* Чем больше размерность матрицы, тем меньше процент заполнения, при котором алгоритм разрежённой матрицы становится 
менее эффективным, чем классический.

Из таблицы видно, что с увеличением процента заполнения алгоритм потребляет больше памяти, причём чем выше процент, тем
быстрее падает производительность (как по времени, так и по памяти).

## Контрольные вопросы
1. **Что такое разреженная матрица, какие схемы хранения таких матриц Вы знаете?** В виде матриц достаточно широко
представляется информация во многих областях человеческой жизнедеятельности. Матричные задачи часто используются при
решении разреженных линейных алгебраических уравнений; разреженных обычных и обобщенных спектральных задач, при этом
матрицы могут быть достаточно большие (больше 10^(10~20) элементов), а число ненулевых элементов при матрице порядка `n`
может выражаться как `n`, где `g < 1`.
2. **Каким образом и сколько памяти выделяется под хранение разреженной и обычной матрицы?** Существуют различные методы
хранения элементов матрицы в памяти. Например, линейный связный список, т.е. последовательность ячеек, связанных в
определенном порядке. Каждая ячейка списка содержит элемент списка и указатель на положение следующей ячейки. Можно
хранить матрицу, используя кольцевой связный список, двунаправленные стеки и очереди. Существует диагональная схема
хранения симметричных матриц, а также связные схемы разреженного хранения.
3. **Каков принцип обработки разреженной матрицы?** *Разреженный вектор* - это разреженная матрица-строка или
матрица-столбец, поэтому рассмотрим скалярное умножение разреженных векторов (как частный случай работы с матрицей) с
использованием так называемого расширенного массива указателей IP. При вычислении стандартным способом нужно `N^2`
просмотров массива. Для сокращения алгебраических операций удобно во время работы хранить расширенный (по размерности
массивов `a` и `b`) массив указателей `IP` (его начальное состояние - нулевое). Этот массив заполняется путем одного
просмотра массива `JA`.
4. **В каком случае для матриц эффективнее применять стандартные алгоритмы обработки матриц? От чего это зависит?** В
случае, если матрица содержит большое количество ненулевых элементов. При этом не должно стоять значительных ограничений
по памяти, так как стандартные матрицы при больших размерностях занимают достаточно много памяти.
