# Задача №4
## Обработка очередей
**Цель работы:** отработка навыков работы с типом данных «очередь», представленным
в виде одномерного массива и односвязного линейного списка. Сравнительный
анализ реализации алгоритмов включения и исключения элементов из очереди при
использовании двух указанных структур данных. Оценка эффективности программы
(при различной реализации) по времени и по используемому объему памяти.

### Задание
Система массового обслуживания состоит из обслуживающих аппаратов (ОА) и
очередей заявок двух типов, различающихся временем прихода и обработки.
Заявки поступают в очереди по случайному закону с различными интервалами
времени (в зависимости от варианта задания), равномерно распределенными от
начального значения (иногда от нуля) до максимального количества единиц
времени. В ОА заявки поступают из «головы» очереди по одной и обслуживаются за
указанные в задании времена, распределенные равновероятно от минимального до
максимального значений (все времена – вещественного типа).

Требуется смоделировать процесс обслуживания первых 1000 заявок первого типа,
выдавая после обслуживания каждых 100 заявок первого типа информацию о текущей
и средней длине каждой очереди и о среднем времени пребывания заявок каждого
типа в очереди. В конце процесса необходимо выдать на экран общее время
моделирования, время простоя ОА, количество вошедших в систему и вышедших из
нее заявок первого и второго типов.

Очередь необходимо представить в виде вектора и списка. Все операции должны
быть оформлены подпрограммами. Алгоритм для реализации задачи один, независимо
от формы представления очереди. Необходимо сравнить эффективность различного
представления очереди по времени выполнения программы и по требуемой памяти.
При реализации очереди списком нужно проследить, каким образом происходит
выделение и освобождение участков памяти, для чего по запросу пользователя
необходимо выдать на экран адреса памяти, содержащие элементы очереди при
добавлении или удалении очередного элемента.

Длительности обработки заявок и интервалы между их приходом (единицы времени -
е.в.) – случайные равномерно распределенные числа вещественного типа в
указанном диапазоне (например, от `t1` до `t2`). Для получения случайной
величины в указанном диапазоне значений можно использовать генератор случайных
чисел с параметром функции от `0` до `1`, возвращающий значение `t`. Используя
линейное преобразование `time = (t2–t1)*t + t1` можно получить необходимое
время. Имея время прихода первой заявки, допустим, `t[прихода1]= time`, можно
определить время прихода следующей заявки как
`t[прихода2] = t[прихода1]+ time`. Следовательно, время прихода 1000 заявок
будет равно `t[прихода] = sum([t[приходаi] for i in range(0, 1000)])`

В один и тот же момент времени одна заявка может придти в очередь, а другая –
начать обрабатываться или выйти из системы. Допустим, пришла заявка первого
типа, а в этот же момент заявка второго типа закончила обработку и вышла из
системы, т.е. `t[прихода1] = t[обработки2] = t[выхода2]`. Таким образом,
модельное время прихода заявки первого типа в систему и модельное время выхода
заявки второго типа из системы совпали. Процессы обработки одной заявки и
прихода другой заявки идут одновременно, т.е. протекают во времени параллельно,
а не последовательно.

### Лабораторная работа

*Очередь* – это последовательный список переменной длины, включение в который
идет с одной стороны (с хвоста), а исключение – с другой стороны (с головы).
Принцип работы очереди: первым пришел – первым вышел, то есть, First In – First
Out (FIFO).  

Моделировать простейшую линейную очередь можно на основе вектора (статического
или динамического) или на основе списка. 

В один и тот же момент одна заявка может придти в очередь, а другая – начать
обрабатываться или выйти из системы.

Процент расхождения расчетного времени и получившегося при работе программы
должен быть не больше 2-3%

Расчетное время моделирование (по входу) = среднее время прихода заявки *
количество вошедших заявок. 

Если есть 2 очереди, то расчет идет для каждой из очередей.

Расчетное время моделирование (по выходу) = среднее время обработки заявки *
количество обработанных заявок.

Если есть 2 очереди и один аппарат, то время моделирования будет суммой времен
обслуживаний заявок каждого типа.

Если время обработки больше времени прихода, то очередь будет расти, и время
моделирования будет определяться временем обработки, а количество вошедших
заявок будет = времени моделирования /  среднее время прихода заявки.
Если время прихода больше времени обработки, то очереди не будет, и время
моделирования будет определяться временем прихода заявок.

### Вариантная чать
Система массового обслуживания состоит из двух обслуживающих аппаратов (ОА1 и
ОА2) и двух очередей заявок. Всего в системе обращается **100** заявок.

Заявки поступают в "хвост" каждой очереди; в ОА они поступают из "головы"
очереди по одной и обслуживаются по случайному закону за интервалы времени
`Т1` и `Т2`, равномерно распределенные от **0 до 6** и от **1 до 8** единиц
времени соответственно. (Все времена – **вещественного** типа). Каждая заявка
после ОА1 c вероятностью **Р=0.7** вновь поступает в "хвост" первой очереди,
совершая новый цикл обслуживания, а с вероятностью **1-Р** входит во вторую
очередь. В начале процесса все заявки находятся в первой очереди.

Смоделировать процесс обслуживания до выхода из ОА2 первых 1000 заявок.
Выдавать на экран после обслуживания  в ОА2 каждых 100 заявок информацию о
текущей и средней длине каждой очереди, а в конце процесса - общее время
моделирования, время простоя ОА2, количество срабатываний ОА1, среднее времени
пребывания заявок в очереди. Обеспечить по требованию пользователя выдачу на
экран адресов элементов очереди при удалении и добавлении элементов.
Проследить, возникает ли при этом фрагментация памяти.



